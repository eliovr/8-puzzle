package puzzle

/**
* Set up for the 15-Puzzle game (https://en.wikipedia.org/wiki/15_puzzle).
* Here you'll find what you need to code and practice search algorithms
* using Scala.
*/
import puzzle._

trait Puzzle {
	def children(): List[Puzzle]
	def isSolution: Boolean
	def printBoard(): Unit
	def printTrace(): Unit
}

/**
* This object is used as the "empty" parent of the root puzzle.
*/
object EmptyPuzzle extends Puzzle {
	def children(): List[Puzzle] = Nil
	def isSolution: Boolean = false
	def printBoard(): Unit = println("Empty puzzle")
	def printTrace(): Unit = println("Empty")
}

/**
* The Puzzle case class is just a wrapper around a board (see package.scala)
* with the implementation of a few convinience methods given by the Puzzle trait.
* @param board a list of integers representing the current state of the puzzle.
* @param parent represents the parent node from which this puzzle derived. Used
* 	to track back how a puzzle was solved.
*/
case class EightPuzzle (board: Board, parent: Puzzle) extends Puzzle {
	/**
	* Returns a list of new puzzles representing the possible states (moves) that
	* derive from the current state. These are generated by "moving" tiles according
	* to the restrictions of the puzzle.
	*/
	def children(): List[Puzzle] = {
		/**
		* Swap the position of two elements given their index in the list.
		*/
		def swap(i1: Int, i2: Int): Puzzle = {
			require(i1 < i2, "i1 should be an index lower than i2")
			val (a, h1 :: b) = board.splitAt(i1)
			val (c, h2 :: d) = b.splitAt(i2 - i1 - 1)
			EightPuzzle(a ::: (h2 :: c) ::: (h1 :: d), this)
		}

		var moves: List[Puzzle] = Nil
		val i = board.indexWhere(_ == 0)
		val row = i / 3
		val col = i - (3 * row)

		if (col < 2) moves = swap(i, i + 1) :: moves	// right
		if (col > 0) moves = swap(i - 1, i) :: moves	// left
		if (row < 2) moves = swap(i, i + 3) :: moves	// bottom
		if (row > 0) moves = swap(i - 3, i) :: moves	// top

		moves
	}

	/**
	* Returns true if the given puzzle represents a solution, false otherwise.
	*/
	def isSolution: Boolean = board.filter(_ != 0) == EightPuzzle.solution

	/**
	* Prints the puzzle out to console in a puzzle-like form.
	*/
	def printBoard(): Unit = board.zipWithIndex.foreach{
		case (c, i) =>
			print(c + " ")
			if ((i + 1) % 3 == 0) println
	}

	def printTrace(): Unit = {
		printBoard()
		println("---")
		parent.printTrace()
	}
}

object EightPuzzle {
	val solution = (1 to 8).toList

	/**
	* Returns a Puzzle with a randomly generated state (i.e., tiles placed randomly)
	* in the board.
	*/
	def generate(): EightPuzzle = {
		val board = scala.util.Random.shuffle((0 to 8).toList)
		EightPuzzle(board, EmptyPuzzle)
	}
}
